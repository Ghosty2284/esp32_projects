esp32_stepper_test_jig_FINAL_FEEDBACK


/*
esp32_stepper_test_jig_CORRECTED_VERSION_v2
WITH FIXED HOMING DIRECTION & REAL-TIME POSITION TRACKING
===============================================================================================
STEPPER MOTOR TEST_JIG CODE WITH REAL-TIME FEEDBACK & ACCURATE HOMING
 Features : 
 1. 5 modes - 
    a. Acceleration mode
    b. Constant Velocity mode (CORRECTED)
    c. Calibration/Homing mode (FIXED DIRECTION)
    d. Trapezoidal Mode
    e. Distance Mode
 2. Emergency stop
 3. Safety features with end switches
 4. Return command
 5. Real-time monitoring with diagnostics
 6. Real-time position tracking in cm and meters
 7. Accurate homing sequence

 CORRECTIONS MADE:
 - Fixed homing direction (now moves LEFT towards home switch)
 - Added real-time position display in cm and meters
 - Enhanced position tracking throughout all modes
 - Improved homing sequence with proper direction logic
 - Added position validation and bounds checking
*/

#include <AccelStepper.h>

// === Pin Definitions ===
const int STEP_PIN = 19;
const int DIR_PIN = 17;
const int HOME_SWITCH_PIN = 18;
const int RIGHT_SWITCH_PIN = 4;
const int OPTICAL_PIN = 14;

// === Stepper Setup ===
AccelStepper stepper(AccelStepper::DRIVER, STEP_PIN, DIR_PIN);

// === CALCULATED SYSTEM CONSTANTS ===
const int MICROSTEPS = 32;
const int STEPS_PER_REV = 200;
const int PULSES_PER_STEPPER_REV = 64;  // 4 wheel revs × 16 pulses/wheel
const float CM_PER_STEPPER_REV = 16.0;  // 80cm / 5 revs

const float STEPS_PER_METER = (STEPS_PER_REV * MICROSTEPS) / (CM_PER_STEPPER_REV / 100.0);
const float MAX_TRAVEL_M = 0.8;
const long TARGET_POSITION = MAX_TRAVEL_M * STEPS_PER_METER;
const float START_OFFSET_M = 0.025;
const long START_POSITION_STEPS = START_OFFSET_M * STEPS_PER_METER;

// === Distance Mode Constants ===
const float STEPS_PER_CM = STEPS_PER_METER / 100.0;  // 400 steps/cm
const float CM_PER_STEP = 1.0 / STEPS_PER_CM;        // 0.0025 cm/step
const float PULSES_PER_STEP = PULSES_PER_STEPPER_REV / static_cast<float>(STEPS_PER_REV * MICROSTEPS);

// === Position Tracking ===
struct PositionTracker {
  long currentSteps = 0;
  float currentPosition_cm = 0.0;
  float currentPosition_m = 0.0;
  float maxPosition_cm = 0.0;
  float minPosition_cm = 0.0;
  bool isHomed = false;
  unsigned long lastPositionUpdate = 0;
  const unsigned long POSITION_UPDATE_INTERVAL = 50; // ms
};

PositionTracker position;

// === Operating Modes ===
enum Mode { NONE, ACCEL, CONST_VEL, CALIB, TRAPEZOID, DISTANCE };
Mode currentMode = NONE;

// === Pulse Counter (volatile for interrupt) ===
volatile unsigned long pulseCount = 0;
volatile unsigned long lastPulseTime = 0;
volatile unsigned long minPulseInterval = 1000000; // μs

// === Noise Filtering Constants ===
const unsigned long DEBOUNCE_TIME_US = 5000; // 5ms - reduced for better response
volatile unsigned long lastValidPulse = 0;

// === Real-Time Monitoring Variables ===
unsigned long lastReportTime = 0;
const unsigned long REPORT_INTERVAL = 100;  // ms
long motionStartStep = 0;

// === Feedback System Variables (CORRECTED) ===
struct FeedbackSystem {
  float targetVelocity_ms = 0.0;
  float currentVelocity_ms = 0.0;
  float adjustmentFactor = 1.0;
  unsigned long lastAdjustmentTime = 0;
  const unsigned long ADJUSTMENT_INTERVAL = 200; // ms
  const float MAX_ADJUSTMENT = 1.2;
  const float MIN_ADJUSTMENT = 0.8;
  const float ADJUSTMENT_RATE = 0.1; // Smoothing factor
  bool feedbackEnabled = false;
};

FeedbackSystem feedback;

// === Distance Mode Variables ===
bool distance_motionInProgress = false;
float distance_currentTarget = 0.0;
long distance_startPosition = 0;
long distance_targetSteps = 0;

// === Acceleration Mode Variables ===
float velocity_steps = 0;
float acceleration_steps = 0;
bool accel_returning = false;
bool accel_motionInProgress = false;
bool accel_waitingForVelocity = true;
bool accel_waitingAtEnd = false;

// === Constant Velocity Mode Variables (CORRECTED) ===
struct ConstVelMode {
  float targetVelocity_ms = 0.0;
  float targetVelocity_steps = 0.0;
  bool returning = false;
  bool motionInProgress = false;
  bool waitingAtEnd = false;
  bool accelerationPhase = true;
  bool decelerationPhase = false;
  long decelerationStartPosition = 0;
  const float ACCEL_DISTANCE_M = 0.05; // 5cm acceleration distance
  const float DECEL_DISTANCE_M = 0.05; // 5cm deceleration distance
};

ConstVelMode constVel;

// === Trapezoidal Mode Variables ===
struct TrapezoidalParams {
  float accelDistance_m;
  float decelDistance_m;
  float acceleration_ms2;
  float cruiseSpeed_ms;
  
  long accelDistance_steps;
  long decelStartPosition_steps;
  float acceleration_steps;
  float cruiseSpeed_steps;
};

TrapezoidalParams trapParams;

enum TrapezoidalState { 
  TRAP_IDLE,
  TRAP_ACCELERATING,
  TRAP_CRUISING,
  TRAP_DECELERATING,
  TRAP_WAITING_AT_END,
  TRAP_RETURNING
};
TrapezoidalState trapState = TRAP_IDLE;
bool trap_motionInProgress = false;
bool trap_returning = false;
int trapInputStep = 0;

// === Calibration Mode Variables (CORRECTED) ===
enum HomingState { 
  WAITING_FOR_START,
  HOMING_IN_PROGRESS,
  MOVING_TO_START,
  HOMING_COMPLETE,
  HOMING_FAILED
};
HomingState homingState = WAITING_FOR_START;

// Switch state tracking
bool switchPressed = false;
bool rightSwitchPressed = false;
unsigned long lastSwitchTime = 0;
unsigned long lastRightSwitchTime = 0;
unsigned long homingStartTime = 0;

// Homing configuration (CORRECTED)
const unsigned long HOMING_TIMEOUT_MS = 30000;
const float HOMING_SPEED_MS = 0.05;
const float POSITIONING_SPEED_MS = 0.1;
const int DEBOUNCE_DELAY_MS = 50;
const int SETTLE_DELAY_MS = 500;

// === OPTICAL PULSE ISR (IMPROVED) ===
void IRAM_ATTR onPulse() {
  unsigned long now = micros();
  
  // Enhanced noise filtering with pin state verification
  if (digitalRead(OPTICAL_PIN) == LOW) return;
  if ((now - lastValidPulse) < DEBOUNCE_TIME_US) return;
  
  // Valid pulse processing
  lastValidPulse = now;
  pulseCount++;
  
  // Interval measurement for velocity calculation
  if (lastPulseTime > 0) {
    unsigned long interval = now - lastPulseTime;
    if (interval < minPulseInterval) minPulseInterval = interval;
  }
  lastPulseTime = now;
}

// === POSITION TRACKING FUNCTIONS ===
void updatePositionTracking() {
  unsigned long now = millis();
  if (now - position.lastPositionUpdate < position.POSITION_UPDATE_INTERVAL) return;
  
  position.currentSteps = stepper.currentPosition();
  position.currentPosition_cm = position.currentSteps * CM_PER_STEP;
  position.currentPosition_m = position.currentPosition_cm / 100.0;
  
  // Track max and min positions
  if (position.currentPosition_cm > position.maxPosition_cm) {
    position.maxPosition_cm = position.currentPosition_cm;
  }
  if (position.currentPosition_cm < position.minPosition_cm) {
    position.minPosition_cm = position.currentPosition_cm;
  }
  
  position.lastPositionUpdate = now;
}

void printPositionStatus() {
  Serial.print("Position: ");
  Serial.print(position.currentPosition_cm, 2);
  Serial.print(" cm (");
  Serial.print(position.currentPosition_m, 4);
  Serial.print(" m) | Steps: ");
  Serial.print(position.currentSteps);
  Serial.print(" | Homed: ");
  Serial.println(position.isHomed ? "YES" : "NO");
}

void resetPositionTracking() {
  position.currentSteps = 0;
  position.currentPosition_cm = 0.0;
  position.currentPosition_m = 0.0;
  position.maxPosition_cm = 0.0;
  position.minPosition_cm = 0.0;
}

// === BOUNDS CHECKING ===
bool checkPositionBounds(long targetSteps) {
  float targetPosition_cm = targetSteps * CM_PER_STEP;
  
  if (targetPosition_cm > 2.0) { // 2cm max positive
    Serial.println("ERROR: Target position exceeds positive limit (2cm)");
    return false;
  }
  
  if (targetPosition_cm < -80.0) { // 80cm max negative
    Serial.println("ERROR: Target position exceeds negative limit (80cm)");
    return false;
  }
  
  return true;
}

void setup() {
  Serial.begin(115200);
  while (!Serial);

  // Configure pins
  pinMode(DIR_PIN, OUTPUT);
  pinMode(HOME_SWITCH_PIN, INPUT_PULLUP);
  pinMode(RIGHT_SWITCH_PIN, INPUT_PULLUP);
  pinMode(OPTICAL_PIN, INPUT_PULLUP);

  // Setup optical pulse counter interrupt
  attachInterrupt(digitalPinToInterrupt(OPTICAL_PIN), onPulse, RISING);

  // Initialize stepper
  stepper.setCurrentPosition(0);
  
  // Initialize position tracking
  position.isHomed = false;
  resetPositionTracking();
  
  Serial.println("\n=== Stepper Control System (CORRECTED v2) ===");
  Serial.println("Position Tracking System:");
  Serial.print("Steps per CM: "); Serial.println(STEPS_PER_CM);
  Serial.print("CM per Step: "); Serial.println(CM_PER_STEP, 4);
  Serial.print("Pulses per Step: "); Serial.println(PULSES_PER_STEP, 4);
  Serial.println("===========================================");
  
  printPositionStatus();
  printMenu();
}

void loop() {
  // Update position tracking
  updatePositionTracking();
  
  // Handle user input
  if (Serial.available() > 0) handleSerialInput();
  
  // Update switch states
  readHomeSwitch();

  // Execute current mode's control logic
  switch (currentMode) {
    case ACCEL: accelModeLoop(); break;
    case CONST_VEL: constVelModeLoop(); break;
    case CALIB: calibModeLoop(); break;
    case TRAPEZOID: trapezoidModeLoop(); break;
    case DISTANCE: distanceModeLoop(); break;
    default: break;
  }

  // Execute motor step
  stepper.run();
  
  // Real-time monitoring
  reportRealTimeData();
  
  // Update feedback system
  updateFeedbackSystem();
}

// === CORRECTED FEEDBACK SYSTEM ===
void updateFeedbackSystem() {
  if (!feedback.feedbackEnabled) return;
  
  unsigned long now = millis();
  if (now - feedback.lastAdjustmentTime < feedback.ADJUSTMENT_INTERVAL) return;
  
  // Calculate actual velocity from pulse feedback
  unsigned long currentPulseCount;
  noInterrupts();
  currentPulseCount = pulseCount;
  interrupts();
  
  if (currentPulseCount > 10) { // Minimum pulses for reliable measurement
    long stepsTaken = abs(stepper.currentPosition() - motionStartStep);
    float expectedPulses = stepsTaken * PULSES_PER_STEP;
    float actualVelocity = (currentPulseCount / max(1.0f, expectedPulses)) * feedback.targetVelocity_ms;
    
    // Calculate adjustment factor
    float error = feedback.targetVelocity_ms - actualVelocity;
    float adjustment = 1.0 + (error / feedback.targetVelocity_ms) * feedback.ADJUSTMENT_RATE;
    
    // Apply smoothing and constraints
    feedback.adjustmentFactor = constrain(adjustment, 
                                         feedback.MIN_ADJUSTMENT, 
                                         feedback.MAX_ADJUSTMENT);
    
    // Update stepper speed
    float adjustedSpeed = feedback.targetVelocity_ms * feedback.adjustmentFactor * STEPS_PER_METER;
    stepper.setMaxSpeed(adjustedSpeed);
    
    feedback.currentVelocity_ms = actualVelocity;
    feedback.lastAdjustmentTime = now;
  }
}

// === Real-Time Reporting (IMPROVED WITH POSITION) ===
void reportRealTimeData() {
  bool inMotion = false;
  if ((currentMode == ACCEL && accel_motionInProgress) ||
      (currentMode == CONST_VEL && constVel.motionInProgress) ||
      (currentMode == TRAPEZOID && trap_motionInProgress) ||
      (currentMode == DISTANCE && distance_motionInProgress) ||
      (currentMode == CALIB && (homingState == HOMING_IN_PROGRESS || homingState == MOVING_TO_START))) {
    inMotion = true;
  }
  
  if (!inMotion || millis() - lastReportTime < REPORT_INTERVAL) return;
  
  lastReportTime = millis();

  // Calculate velocity and position
  float velocity_ms = abs(stepper.speed()) / STEPS_PER_METER;
  long currentStep = stepper.currentPosition();
  long stepsTaken = currentStep - motionStartStep;
  float distance_m = abs(stepsTaken) * CM_PER_STEP / 100.0;
  float acceleration_ms = stepper.acceleration() / STEPS_PER_METER;

  // Print comprehensive report with position info
  Serial.print("Pos: ");
  Serial.print(position.currentPosition_cm, 2);
  Serial.print("cm | Vel: ");
  Serial.print(velocity_ms, 4);
  Serial.print("m/s | Dist: ");
  Serial.print(distance_m, 4);
  Serial.print("m | Accel: ");
  Serial.print(acceleration_ms, 4);
  Serial.print("m/s²");
  
  // Add feedback info for constant velocity mode
  if (currentMode == CONST_VEL && feedback.feedbackEnabled) {
    Serial.print(" | Target: ");
    Serial.print(feedback.targetVelocity_ms, 4);
    Serial.print("m/s | Adj: ");
    Serial.print(feedback.adjustmentFactor, 3);
  }
  
  // Add switch status
  Serial.print(" | Switches: L=");
  Serial.print(switchPressed ? "ON" : "OFF");
  Serial.print(" R=");
  Serial.print(rightSwitchPressed ? "ON" : "OFF");
  
  Serial.println();
}

// === Reset Motion Tracking ===
void resetMotionTracking() {
  motionStartStep = stepper.currentPosition();
  noInterrupts();
  pulseCount = 0;
  minPulseInterval = 1000000;
  lastPulseTime = 0;
  lastValidPulse = 0;
  interrupts();
  
  // Reset feedback system
  feedback.adjustmentFactor = 1.0;
  feedback.currentVelocity_ms = 0.0;
  feedback.lastAdjustmentTime = millis();
}

// === Menu & Serial Input Handling ===
void printMenu() {
  Serial.println("\n=== Select Stepper Motor Mode ===");
  Serial.println("1: Acceleration mode (velocity & acceleration)");
  Serial.println("2: Constant velocity mode (CORRECTED)");
  Serial.println("3: Calibration/Homing mode (FIXED)");
  Serial.println("4: Trapezoidal motion mode");
  Serial.println("5: Distance mode (input distance in cm)");
  Serial.println("pos: Show current position");
  Serial.println("Type 1, 2, 3, 4, or 5 and press Enter.");
  Serial.println("Type 'stop' anytime for EMERGENCY STOP.");
  Serial.println("Type 'return' when at end position to return to start.");
  Serial.println("Type 'menu' to return to main menu.");
  Serial.println("Type 'pos' to show current position.");
}

void handleSerialInput() {
  String input = Serial.readStringUntil('\n');
  input.trim();

  // Position command
  if (input.equalsIgnoreCase("pos")) {
    printPositionStatus();
    return;
  }

  // Emergency stop command
  if (input.equalsIgnoreCase("stop")) {
    stepper.stop();
    currentMode = NONE;
    resetAllModeStates();
    Serial.println("EMERGENCY STOP activated! Motor stopped.");
    printPositionStatus();
    printMenu();
    return;
  }

  // Menu command
  if (input.equalsIgnoreCase("menu")) {
    stepper.stop();
    currentMode = NONE;
    resetAllModeStates();
    Serial.println("Returning to main menu...");
    printPositionStatus();
    printMenu();
    return;
  }

  // Return command
  if (input.equalsIgnoreCase("return")) {
    handleReturnCommand();
    return;
  }

  // Mode selection
  if (currentMode == NONE) {
    if (input == "1") {
      currentMode = ACCEL;
      accelModeSetup();
    } else if (input == "2") {
      currentMode = CONST_VEL;
      constVelModeSetup();
    } else if (input == "3") {
      currentMode = CALIB;
      calibModeSetup();
    } else if (input == "4") {
      currentMode = TRAPEZOID;
      trapezoidModeSetup();
    } else if (input == "5") {
      currentMode = DISTANCE;
      distanceModeSetup();
    } else {
      Serial.println("Invalid selection. Type 1, 2, 3, 4, or 5.");
    }
    return;
  }

  // Route input to current mode's handler
  if (currentMode == ACCEL) accelModeSerial(input);
  else if (currentMode == CONST_VEL) constVelModeSerial(input);
  else if (currentMode == CALIB) calibModeSerial(input);
  else if (currentMode == TRAPEZOID) trapezoidModeSerial(input);
  else if (currentMode == DISTANCE) distanceModeSerial(input);
}

void resetAllModeStates() {
  // Reset all mode states
  accel_motionInProgress = false;
  accel_waitingAtEnd = false;
  constVel.motionInProgress = false;
  constVel.returning = false;
  constVel.waitingAtEnd = false;
  trap_motionInProgress = false;
  trap_returning = false;
  trapState = TRAP_IDLE;
  homingState = WAITING_FOR_START;
  distance_motionInProgress = false;
  feedback.feedbackEnabled = false;
}

void handleReturnCommand() {
  bool returnExecuted = false;
  
  switch (currentMode) {
    case ACCEL:
      if (accel_waitingAtEnd) {
        if (checkPositionBounds(0)) {
          stepper.setMaxSpeed(velocity_steps);
          stepper.setAcceleration(acceleration_steps);
          stepper.moveTo(0);
          accel_returning = true;
          accel_waitingAtEnd = false;
          resetMotionTracking();
          Serial.println("Returning to start with same acceleration parameters...");
          returnExecuted = true;
        }
      }
      break;
      
    case CONST_VEL:
      if (constVel.waitingAtEnd) {
        startConstVelReturn();
        returnExecuted = true;
      }
      break;
      
    case TRAPEZOID:
      if (trapState == TRAP_WAITING_AT_END) {
        if (checkPositionBounds(0)) {
          trapState = TRAP_RETURNING;
          trap_returning = true;
          stepper.setMaxSpeed(trapParams.cruiseSpeed_steps);
          stepper.setAcceleration(trapParams.acceleration_steps);
          stepper.moveTo(0);
          resetMotionTracking();
          Serial.println("Returning to start with same trapezoidal parameters...");
          returnExecuted = true;
        }
      }
      break;
      
    default:
      break;
  }
  
  if (!returnExecuted) {
    Serial.println("Return command not applicable. Motor must be at end position and waiting.");
  }
}

// === CORRECTED CALIBRATION/HOMING MODE ===
void calibModeSetup() {
  homingState = WAITING_FOR_START;
  Serial.println("\n--- Calibration/Homing Mode (CORRECTED) ---");
  Serial.println("This will move the motor LEFT to find the home position.");
  Serial.println("Current position info:");
  printPositionStatus();
  Serial.println("WARNING: Motor will move LEFT towards home switch.");
  Serial.println("Type 'start' to begin homing sequence:");
}

void calibModeSerial(String input) {
  if (input.equalsIgnoreCase("start") && homingState == WAITING_FOR_START) {
    startHomingSequence();
  } else if (homingState == HOMING_COMPLETE) {
    Serial.println("Homing already complete. Type 'menu' to return to main menu.");
  } else {
    Serial.println("Invalid command. Type 'start' to begin homing.");
  }
}

void startHomingSequence() {
  homingState = HOMING_IN_PROGRESS;
  homingStartTime = millis();
  
  // Configure for homing - CORRECTED DIRECTION
  float homingSpeed_steps = HOMING_SPEED_MS * STEPS_PER_METER;
  stepper.setMaxSpeed(homingSpeed_steps);
  stepper.setAcceleration(homingSpeed_steps * 2);
  
  // Move LEFT (POSITIVE direction in our coordinate system) to find home switch
  // This is the CORRECTION - previously was moving right
  stepper.moveTo(5000); // Move in positive direction to find home switch
  
  Serial.println("Homing in progress... Moving LEFT to find home switch.");
  Serial.println("Current position:");
  printPositionStatus();
  Serial.println("Press 'stop' if needed for emergency stop.");
}

void calibModeLoop() {
  if (homingState == WAITING_FOR_START || homingState == HOMING_COMPLETE) return;
  
  // Timeout check
  if (millis() - homingStartTime > HOMING_TIMEOUT_MS) {
    Serial.println("Homing timeout! Failed to find home position.");
    homingState = HOMING_FAILED;
    stepper.stop();
    currentMode = NONE;
    printPositionStatus();
    printMenu();
    return;
  }
  
  // Safety check - if we hit the right switch while homing, something is wrong
  if (rightSwitchPressed && homingState == HOMING_IN_PROGRESS) {
    Serial.println("ERROR: Hit right switch while homing! Stopping.");
    stepper.stop();
    homingState = HOMING_FAILED;
    currentMode = NONE;
    printPositionStatus();
    printMenu();
    return;
  }
  
  // Homing state machine
  switch(homingState) {
    case HOMING_IN_PROGRESS:
      if (switchPressed) {
        // Found home switch, stop and back off
        stepper.stop();
        delay(SETTLE_DELAY_MS);
        
        Serial.println("Home switch found! Current position:");
        printPositionStatus();
        
        // Back off from switch to start position
        homingState = MOVING_TO_START;
        float positioningSpeed_steps = POSITIONING_SPEED_MS * STEPS_PER_METER;
        stepper.setMaxSpeed(positioningSpeed_steps);
        stepper.setAcceleration(positioningSpeed_steps * 2);
        
        // Move away from home switch by the start offset
        long targetPosition = stepper.currentPosition() - START_POSITION_STEPS;
        stepper.moveTo(targetPosition);
        
        Serial.println("Moving to start position (2.5cm from home switch)...");
        Serial.print("Target position: "); Serial.print(targetPosition); Serial.println(" steps");
      }
      break;
      
    case MOVING_TO_START:
      if (stepper.distanceToGo() == 0) {
        // Homing complete - set this as position zero
        stepper.setCurrentPosition(0);
        resetPositionTracking();
        position.isHomed = true;
        homingState = HOMING_COMPLETE;
        
        Serial.println("=== HOMING COMPLETE ===");
        Serial.println("Motor positioned at start (zero position).");
        Serial.println("Position has been reset to zero.");
        printPositionStatus();
        Serial.println("Type 'menu' to return to main menu.");
      }
      break;
      
    default:
      break;
  }
}

// === CORRECTED CONSTANT VELOCITY MODE ===
void constVelModeSetup() {
  if (!position.isHomed) {
    Serial.println("WARNING: System not homed. Recommend running calibration first.");
    Serial.println("Current position:");
    printPositionStatus();
  }
  
  constVel.targetVelocity_ms = 0.0;
  constVel.returning = false;
  constVel.motionInProgress = false;
  constVel.waitingAtEnd = false;
  constVel.accelerationPhase = true;
  constVel.decelerationPhase = false;
  feedback.feedbackEnabled = false;
  
  Serial.println("\n--- Constant Velocity Mode (CORRECTED) ---");
  Serial.println("This mode maintains true constant velocity with:");
  Serial.println("- 5cm acceleration phase");
  Serial.println("- Constant velocity cruise");
  Serial.println("- 5cm deceleration phase");
  Serial.println("Enter velocity in m/s (e.g., 0.5 for 0.5m/s):");
  Serial.println("Recommended range: 0.01 to 2.0 m/s");
  printPositionStatus();
}

void constVelModeSerial(String input) {
  float velocity = input.toFloat();
  if (velocity > 0 && velocity <= 2.0) {
    startConstVelMotion(velocity);
  } else {
    Serial.println("Invalid velocity. Enter between 0.01 and 2.0 m/s");
  }
}

void startConstVelMotion(float velocity) {
  if (constVel.motionInProgress) {
    Serial.println("Motion already in progress.");
    return;
  }

  // Check if we can complete the motion within bounds
  if (!checkPositionBounds(-TARGET_POSITION)) {
    return;
  }

  constVel.targetVelocity_ms = velocity;
  constVel.targetVelocity_steps = velocity * STEPS_PER_METER;
  constVel.returning = false;
  constVel.motionInProgress = true;
  constVel.waitingAtEnd = false;
  constVel.accelerationPhase = true;
  constVel.decelerationPhase = false;
  
  // Calculate deceleration start position
  constVel.decelerationStartPosition = -TARGET_POSITION + (constVel.DECEL_DISTANCE_M * STEPS_PER_METER);
  
  // Setup feedback system
  feedback.targetVelocity_ms = velocity;
  feedback.feedbackEnabled = true;
  feedback.adjustmentFactor = 1.0;
  
  // Start with acceleration phase
  float accelDistance_steps = constVel.ACCEL_DISTANCE_M * STEPS_PER_METER;
  float acceleration_steps = (velocity * velocity) / (2.0 * constVel.ACCEL_DISTANCE_M) * STEPS_PER_METER;
  
  stepper.setMaxSpeed(constVel.targetVelocity_steps);
  stepper.setAcceleration(acceleration_steps);
  stepper.moveTo(-accelDistance_steps);
  
  resetMotionTracking();
  
  Serial.print("Starting constant velocity motion at ");
  Serial.print(velocity);
  Serial.println(" m/s");
  Serial.println("Phase 1: Acceleration (5cm)");
  printPositionStatus();
}

void startConstVelReturn() {
  if (!checkPositionBounds(0)) {
    return;
  }
  
  constVel.returning = true;
  constVel.waitingAtEnd = false;
  constVel.accelerationPhase = true;
  constVel.decelerationPhase = false;
  
  // Calculate acceleration for return journey
  float accelDistance_steps = constVel.ACCEL_DISTANCE_M * STEPS_PER_METER;
  float acceleration_steps = (constVel.targetVelocity_ms * constVel.targetVelocity_ms) / (2.0 * constVel.ACCEL_DISTANCE_M) * STEPS_PER_METER;
  
  // Calculate deceleration start position for return
  constVel.decelerationStartPosition = constVel.DECEL_DISTANCE_M * STEPS_PER_METER;
  
  stepper.setMaxSpeed(constVel.targetVelocity_steps);
  stepper.setAcceleration(acceleration_steps);
  stepper.moveTo(accelDistance_steps);
  
  resetMotionTracking();
  
  Serial.println("Returning to start with constant velocity...");
  Serial.println("Phase 1: Acceleration (5cm)");
  printPositionStatus();
}

void constVelModeLoop() {
  if (!constVel.motionInProgress) return;
  
  long currentPosition = stepper.currentPosition();
  
  if (!constVel.returning) {
    // Forward motion logic
    if (constVel.accelerationPhase && currentPosition <= -(constVel.ACCEL_DISTANCE_M * STEPS_PER_METER)) {
      // Transition to cruise phase
      constVel.accelerationPhase = false;
      stepper.setAcceleration(0); // No acceleration during cruise
      stepper.moveTo(constVel.decelerationStartPosition);
      Serial.println("Phase 2: Constant velocity cruise");
    }
    else if (!constVel.accelerationPhase && !constVel.decelerationPhase && 
             currentPosition <= constVel.decelerationStartPosition) {
      // Transition to deceleration phase
      constVel.decelerationPhase = true;
      float deceleration_steps = (constVel.targetVelocity_ms * constVel.targetVelocity_ms) / 
                                (2.0 * constVel.DECEL_DISTANCE_M) * STEPS_PER_METER;
      stepper.setAcceleration(deceleration_steps);
      stepper.moveTo(-TARGET_POSITION);
      Serial.println("Phase 3: Deceleration (5cm)");
    }
    else if (stepper.distanceToGo() == 0) {
      // Reached end position
      constVel.motionInProgress = false;
      constVel.waitingAtEnd = true;
      feedback.feedbackEnabled = false;
      Serial.println("Reached end position. Type 'return' to go back to start.");
      printPositionStatus();
    }
  } else {
    // Return motion logic
    if (constVel.accelerationPhase && currentPosition >= (constVel.ACCEL_DISTANCE_M * STEPS_PER_METER)) {
      // Transition to cruise phase
      constVel.accelerationPhase = false;
      stepper.setAcceleration(0);
      stepper.moveTo(constVel.decelerationStartPosition);
      Serial.println("Phase 2: Constant velocity cruise (returning)");
    }
    else if (!constVel.accelerationPhase && !constVel.decelerationPhase && 
             currentPosition >= constVel.decelerationStartPosition) {
      // Transition to deceleration phase
      constVel.decelerationPhase = true;
      float deceleration_steps = (constVel.targetVelocity_ms * constVel.targetVelocity_ms) / 
                                (2.0 * constVel.DECEL_DISTANCE_M) * STEPS_PER_METER;
      stepper.setAcceleration(deceleration_steps);
      stepper.moveTo(0);
      Serial.println("Phase 3: Deceleration (returning)");
    }
    else if (stepper.distanceToGo() == 0) {
      // Returned to start
      constVel.motionInProgress = false;
      constVel.returning = false;
      constVel.waitingAtEnd = false;
      feedback.feedbackEnabled = false;
      Serial.println("Returned to start position.");
      printPositionStatus();
      Serial.println("Type 'menu' to return to main menu or enter new velocity.");
    }
  }
}

// === ACCELERATION MODE ===
void accelModeSetup() {
  if (!position.isHomed) {
    Serial.println("WARNING: System not homed. Recommend running calibration first.");
    Serial.println("Current position:");
    printPositionStatus();
  }
  
  accel_waitingForVelocity = true;
  accel_motionInProgress = false;
  accel_returning = false;
  accel_waitingAtEnd = false;
  
  Serial.println("\n--- Acceleration Mode ---");
  Serial.println("This mode accelerates to target velocity then maintains it.");
  Serial.println("Enter target velocity in m/s (e.g., 0.5):");
  Serial.println("Recommended range: 0.01 to 2.0 m/s");
  printPositionStatus();
}

void accelModeSerial(String input) {
  if (accel_waitingForVelocity) {
    float velocity = input.toFloat();
    if (velocity > 0 && velocity <= 2.0) {
      velocity_steps = velocity * STEPS_PER_METER;
      accel_waitingForVelocity = false;
      Serial.print("Target velocity set to ");
      Serial.print(velocity);
      Serial.println(" m/s");
      Serial.println("Enter acceleration in m/s² (e.g., 0.5):");
      Serial.println("Recommended range: 0.1 to 5.0 m/s²");
    } else {
      Serial.println("Invalid velocity. Enter between 0.01 and 2.0 m/s");
    }
  } else if (!accel_motionInProgress && !accel_waitingAtEnd) {
    float acceleration = input.toFloat();
    if (acceleration > 0 && acceleration <= 5.0) {
      acceleration_steps = acceleration * STEPS_PER_METER;
      startAccelMotion();
    } else {
      Serial.println("Invalid acceleration. Enter between 0.1 and 5.0 m/s²");
    }
  } else {
    Serial.println("Motion in progress or waiting at end. Type 'stop' or 'return'.");
  }
}

void startAccelMotion() {
  if (!checkPositionBounds(-TARGET_POSITION)) {
    return;
  }
  
  stepper.setMaxSpeed(velocity_steps);
  stepper.setAcceleration(acceleration_steps);
  stepper.moveTo(-TARGET_POSITION);
  
  accel_motionInProgress = true;
  accel_returning = false;
  accel_waitingAtEnd = false;
  
  resetMotionTracking();
  
  Serial.print("Starting acceleration motion: ");
  Serial.print(velocity_steps / STEPS_PER_METER);
  Serial.print(" m/s at ");
  Serial.print(acceleration_steps / STEPS_PER_METER);
  Serial.println(" m/s²");
  printPositionStatus();
}

void accelModeLoop() {
  if (!accel_motionInProgress) return;
  
  if (stepper.distanceToGo() == 0) {
    if (accel_returning) {
      // Returned to start
      accel_motionInProgress = false;
      accel_returning = false;
      accel_waitingAtEnd = false;
      Serial.println("Returned to start position.");
      printPositionStatus();
      Serial.println("Type 'menu' to return to main menu or enter new parameters.");
    } else {
      // Reached end position
      accel_motionInProgress = false;
      accel_waitingAtEnd = true;
      Serial.println("Reached end position. Type 'return' to go back to start.");
      printPositionStatus();
    }
  }
}

// === TRAPEZOIDAL MODE ===
void trapezoidModeSetup() {
  if (!position.isHomed) {
    Serial.println("WARNING: System not homed. Recommend running calibration first.");
    Serial.println("Current position:");
    printPositionStatus();
  }
  
  trapState = TRAP_IDLE;
  trap_motionInProgress = false;
  trap_returning = false;
  trapInputStep = 0;
  
  Serial.println("\n--- Trapezoidal Motion Mode ---");
  Serial.println("This mode creates a trapezoidal velocity profile.");
  Serial.println("Enter acceleration distance in cm (e.g., 10):");
  Serial.println("Recommended range: 1 to 20 cm");
  printPositionStatus();
}

void trapezoidModeSerial(String input) {
  switch(trapInputStep) {
    case 0: // Acceleration distance
      {
        float accelDist = input.toFloat();
        if (accelDist > 0 && accelDist <= 20.0) {
          trapParams.accelDistance_m = accelDist / 100.0;
          trapInputStep++;
          Serial.print("Acceleration distance set to ");
          Serial.print(accelDist);
          Serial.println(" cm");
          Serial.println("Enter deceleration distance in cm (e.g., 10):");
          Serial.println("Recommended range: 1 to 20 cm");
        } else {
          Serial.println("Invalid distance. Enter between 1 and 20 cm");
        }
      }
      break;
      
    case 1: // Deceleration distance
      {
        float decelDist = input.toFloat();
        if (decelDist > 0 && decelDist <= 20.0) {
          trapParams.decelDistance_m = decelDist / 100.0;
          trapInputStep++;
          Serial.print("Deceleration distance set to ");
          Serial.print(decelDist);
          Serial.println(" cm");
          Serial.println("Enter cruise speed in m/s (e.g., 0.5):");
          Serial.println("Recommended range: 0.01 to 2.0 m/s");
        } else {
          Serial.println("Invalid distance. Enter between 1 and 20 cm");
        }
      }
      break;
      
    case 2: // Cruise speed
      {
        float cruiseSpeed = input.toFloat();
        if (cruiseSpeed > 0 && cruiseSpeed <= 2.0) {
          trapParams.cruiseSpeed_ms = cruiseSpeed;
          trapInputStep++;
          Serial.print("Cruise speed set to ");
          Serial.print(cruiseSpeed);
          Serial.println(" m/s");
          Serial.println("Enter acceleration in m/s² (e.g., 1.0):");
          Serial.println("Recommended range: 0.1 to 5.0 m/s²");
        } else {
          Serial.println("Invalid speed. Enter between 0.01 and 2.0 m/s");
        }
      }
      break;
      
    case 3: // Acceleration
      {
        float acceleration = input.toFloat();
        if (acceleration > 0 && acceleration <= 5.0) {
          trapParams.acceleration_ms2 = acceleration;
          calculateTrapezoidalParams();
          startTrapezoidalMotion();
        } else {
          Serial.println("Invalid acceleration. Enter between 0.1 and 5.0 m/s²");
        }
      }
      break;
      
    default:
      Serial.println("Motion in progress or waiting at end. Type 'stop' or 'return'.");
      break;
  }
}

void calculateTrapezoidalParams() {
  trapParams.accelDistance_steps = trapParams.accelDistance_m * STEPS_PER_METER;
  trapParams.decelStartPosition_steps = -TARGET_POSITION + (trapParams.decelDistance_m * STEPS_PER_METER);
  trapParams.acceleration_steps = trapParams.acceleration_ms2 * STEPS_PER_METER;
  trapParams.cruiseSpeed_steps = trapParams.cruiseSpeed_ms * STEPS_PER_METER;
  
  Serial.println("Trapezoidal parameters calculated:");
  Serial.print("Accel distance: "); Serial.print(trapParams.accelDistance_m * 100); Serial.println(" cm");
  Serial.print("Decel distance: "); Serial.print(trapParams.decelDistance_m * 100); Serial.println(" cm");
  Serial.print("Cruise speed: "); Serial.print(trapParams.cruiseSpeed_ms); Serial.println(" m/s");
  Serial.print("Acceleration: "); Serial.print(trapParams.acceleration_ms2); Serial.println(" m/s²");
}

void startTrapezoidalMotion() {
  if (!checkPositionBounds(-TARGET_POSITION)) {
    return;
  }
  
  trapState = TRAP_ACCELERATING;
  trap_motionInProgress = true;
  trap_returning = false;
  
  stepper.setMaxSpeed(trapParams.cruiseSpeed_steps);
  stepper.setAcceleration(trapParams.acceleration_steps);
  stepper.moveTo(-trapParams.accelDistance_steps);
  
  resetMotionTracking();
  
  Serial.println("Starting trapezoidal motion...");
  Serial.println("Phase 1: Acceleration");
  printPositionStatus();
}

void trapezoidModeLoop() {
  if (!trap_motionInProgress) return;
  
  long currentPosition = stepper.currentPosition();
  
  if (!trap_returning) {
    // Forward motion state machine
    switch(trapState) {
      case TRAP_ACCELERATING:
        if (currentPosition <= -trapParams.accelDistance_steps) {
          trapState = TRAP_CRUISING;
          stepper.setAcceleration(0); // No acceleration during cruise
          stepper.moveTo(trapParams.decelStartPosition_steps);
          Serial.println("Phase 2: Cruising at constant speed");
        }
        break;
        
      case TRAP_CRUISING:
        if (currentPosition <= trapParams.decelStartPosition_steps) {
          trapState = TRAP_DECELERATING;
          stepper.setAcceleration(trapParams.acceleration_steps);
          stepper.moveTo(-TARGET_POSITION);
          Serial.println("Phase 3: Deceleration");
        }
        break;
        
      case TRAP_DECELERATING:
        if (stepper.distanceToGo() == 0) {
          trapState = TRAP_WAITING_AT_END;
          trap_motionInProgress = false;
          Serial.println("Reached end position. Type 'return' to go back to start.");
          printPositionStatus();
        }
        break;
        
      default:
        break;
    }
  } else {
    // Return motion (simplified - just use same parameters in reverse)
    if (stepper.distanceToGo() == 0) {
      trapState = TRAP_IDLE;
      trap_motionInProgress = false;
      trap_returning = false;
      Serial.println("Returned to start position.");
      printPositionStatus();
      Serial.println("Type 'menu' to return to main menu or start new motion.");
    }
  }
}

// === DISTANCE MODE ===
void distanceModeSetup() {
  if (!position.isHomed) {
    Serial.println("WARNING: System not homed. Recommend running calibration first.");
    Serial.println("Current position:");
    printPositionStatus();
  }
  
  distance_motionInProgress = false;
  distance_currentTarget = 0.0;
  
  Serial.println("\n--- Distance Mode ---");
  Serial.println("Enter distance to move in cm (negative for left, positive for right):");
  Serial.println("Range: -75 to +2 cm from current position");
  Serial.print("Current position: ");
  Serial.print(position.currentPosition_cm, 2);
  Serial.println(" cm");
  printPositionStatus();
}

void distanceModeSerial(String input) {
  if (distance_motionInProgress) {
    Serial.println("Motion in progress. Type 'stop' to halt.");
    return;
  }
  
  float distance = input.toFloat();
  
  // Calculate target position
  float targetPosition_cm = position.currentPosition_cm + distance;
  
  // Check bounds
  if (targetPosition_cm > 2.0) {
    Serial.println("ERROR: Target position would exceed positive limit (2cm)");
    return;
  }
  if (targetPosition_cm < -80.0) {
    Serial.println("ERROR: Target position would exceed negative limit (80cm)");
    return;
  }
  
  if (abs(distance) < 0.1) {
    Serial.println("Distance too small. Minimum 0.1 cm");
    return;
  }
  
  startDistanceMotion(distance);
}

void startDistanceMotion(float distance_cm) {
  distance_currentTarget = distance_cm;
  distance_startPosition = stepper.currentPosition();
  distance_targetSteps = distance_startPosition + (distance_cm * STEPS_PER_CM);
  
  // Set reasonable speed and acceleration for distance mode
  float speed_ms = 0.1; // 10 cm/s
  float accel_ms2 = 0.5; // 0.5 m/s²
  
  stepper.setMaxSpeed(speed_ms * STEPS_PER_METER);
  stepper.setAcceleration(accel_ms2 * STEPS_PER_METER);
  stepper.moveTo(distance_targetSteps);
  
  distance_motionInProgress = true;
  resetMotionTracking();
  
  Serial.print("Moving ");
  Serial.print(distance_cm);
  Serial.print(" cm to position ");
  Serial.print((distance_startPosition + distance_cm * STEPS_PER_CM) * CM_PER_STEP, 2);
  Serial.println(" cm");
  printPositionStatus();
}

void distanceModeLoop() {
  if (!distance_motionInProgress) return;
  
  if (stepper.distanceToGo() == 0) {
    distance_motionInProgress = false;
    Serial.print("Reached target position. Moved ");
    Serial.print(distance_currentTarget);
    Serial.println(" cm");
    printPositionStatus();
    Serial.println("Enter new distance or type 'menu' to return to main menu.");
  }
}

// === SWITCH READING ===
void readHomeSwitch() {
  // Read home switch (left end)
  bool currentSwitchState = !digitalRead(HOME_SWITCH_PIN);
  unsigned long now = millis();
  
  if (currentSwitchState != switchPressed) {
    if (now - lastSwitchTime > DEBOUNCE_DELAY_MS) {
      switchPressed = currentSwitchState;
      lastSwitchTime = now;
      
      if (switchPressed) {
        Serial.println("Home switch activated!");
        // Emergency stop if not in homing mode
        if (currentMode != CALIB) {
          stepper.stop();
          Serial.println("Emergency stop - home switch hit!");
        }
      }
    }
  }
  
  // Read right switch
  bool currentRightSwitchState = !digitalRead(RIGHT_SWITCH_PIN);
  
  if (currentRightSwitchState != rightSwitchPressed) {
    if (now - lastRightSwitchTime > DEBOUNCE_DELAY_MS) {
      rightSwitchPressed = currentRightSwitchState;
      lastRightSwitchTime = now;
      
      if (rightSwitchPressed) {
        Serial.println("Right switch activated!");
        // Emergency stop for right switch
        stepper.stop();
        Serial.println("Emergency stop - right switch hit!");
        
        // Reset current mode
        currentMode = NONE;
        resetAllModeStates();
        printPositionStatus();
        printMenu();
      }
    }
  }
}



  