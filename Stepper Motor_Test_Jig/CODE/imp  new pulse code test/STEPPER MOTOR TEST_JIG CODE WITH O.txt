/* STEPPER MOTOR TEST_JIG CODE WITH OPTICAL ENCODER */

#include <AccelStepper.h>

// === Pin Definitions ===
const int STEP_PIN = 19;              // Stepper step signal pin
const int DIR_PIN = 17;               // Stepper direction signal pin
const int HOME_SWITCH_PIN = 18;       // Left limit/home switch (active low)
const int RIGHT_SWITCH_PIN = 4;       // Right safety switch (active low)
const int ENCODER_PIN = 14;           // Optical encoder input pin

// === Stepper Setup ===
AccelStepper stepper(AccelStepper::DRIVER, STEP_PIN, DIR_PIN);

// === System Constants ===
const float STEPS_PER_METER = 40000.0;          // Motor resolution: steps per meter
const float MAX_TRAVEL_M = 0.8;                 // Maximum travel distance (80cm)
const long TARGET_POSITION = MAX_TRAVEL_M * STEPS_PER_METER;  // End position in steps
const float START_OFFSET_M = 0.025;             // 2.5cm offset from home position
const long START_POSITION_STEPS = START_OFFSET_M * STEPS_PER_METER;
const float PULSES_PER_METER = 900.0;           // 720 pulses/0.8m = 900 pulses/m

// === Encoder Variables ===
volatile long pulseCount = 0;                   // Optical encoder pulse counter
bool encoderEnabled = false;                    // Controls when to count pulses

// === Operating Modes ===
enum Mode { NONE, ACCEL, CONST_VEL, CALIB, TRAPEZOID, DISTANCE };
Mode currentMode = NONE;

// === Acceleration Mode Variables ===
// Mode: User sets velocity and acceleration, motor moves with these parameters
float velocity_steps = 0;              // Target velocity in steps/sec
float acceleration_steps = 0;           // Acceleration rate in steps/sec²
bool accel_returning = false;           // Flag: motor returning to start
bool accel_motionInProgress = false;    // Flag: motion is active
bool accel_waitingForVelocity = true;   // Flag: waiting for velocity input
bool accel_waitingAtEnd = false;        // Flag: waiting at end for return command

// === Constant Velocity Mode Variables ===
// Mode: Motor moves at constant speed (instant acceleration to target speed)
float const_currentVelocity = 0.0;     // Current velocity setting (m/s)
bool const_returning = false;           // Flag: motor returning to start
bool const_motionInProgress = false;    // Flag: motion is active
bool const_waitingAtEnd = false;        // Flag: waiting at end for return command

// === Trapezoidal Mode Variables ===
// Mode: Creates trapezoidal velocity profile (accel -> cruise -> decel)
struct TrapezoidalParams {
  // User inputs (in meters and m/s units)
  float accelDistance_m;      // Distance to reach cruise speed
  float decelDistance_m;      // Distance to start deceleration  
  float acceleration_ms2;     // Acceleration/deceleration rate
  float cruiseSpeed_ms;       // Cruise speed
  
  // Calculated values (converted to steps)
  long accelDistance_steps;
  long decelStartPosition_steps;
  float acceleration_steps;
  float cruiseSpeed_steps;
};

TrapezoidalParams trapParams;

// State machine for trapezoidal motion phases
enum TrapezoidalState { 
  TRAP_IDLE,              // Not moving
  TRAP_ACCELERATING,      // Accelerating to cruise speed
  TRAP_CRUISING,          // Moving at constant cruise speed
  TRAP_DECELERATING,      // Decelerating to stop
  TRAP_WAITING_AT_END,    // Waiting at end for return command
  TRAP_RETURNING          // Returning to start position
};
TrapezoidalState trapState = TRAP_IDLE;
bool trap_motionInProgress = false;     // Flag: trapezoidal motion active
bool trap_returning = false;            // Flag: returning to start
int trapInputStep = 0;                  // Parameter input counter (0-3)

// === Calibration Mode Variables ===
// Mode: Homes motor to left switch, then moves to start position
enum HomingState { 
  WAITING_FOR_START,    // Waiting for 'home' command
  HOMING_IN_PROGRESS,   // Moving left to find home switch
  MOVING_TO_START,      // Moving to start position after homing
  HOMING_COMPLETE,      // Homing finished successfully
  HOMING_FAILED         // Homing failed (timeout or no switch)
};
HomingState homingState = WAITING_FOR_START;

// === Distance Mode Variables ===
// Mode: Moves at constant velocity while counting encoder pulses
bool dist_motionInProgress = false;    // Flag: motion is active
bool dist_returning = false;           // Flag: motor returning to start
bool dist_waitingAtEnd = false;        // Flag: waiting at end for return command
float dist_velocity = 0.0;             // Target velocity in m/s
unsigned long lastPrintTime = 0;       // Last encoder print time
const long PRINT_INTERVAL = 100;       // Encoder print interval (ms)

// Switch state tracking with debounce
bool switchPressed = false;             // Left switch state (debounced)
bool rightSwitchPressed = false;        // Right switch state (debounced)
unsigned long lastSwitchTime = 0;       // Left switch debounce timer
unsigned long lastRightSwitchTime = 0;  // Right switch debounce timer
unsigned long homingStartTime = 0;      // Homing operation start time

// Homing configuration constants
const unsigned long HOMING_TIMEOUT_MS = 30000;  // Max time to find home (30s)
const float HOMING_SPEED_MS = 0.05;             // Speed while finding home (5cm/s)
const float POSITIONING_SPEED_MS = 0.1;         // Speed to start position (10cm/s)
const int DEBOUNCE_DELAY_MS = 50;               // Switch debounce time
const int SETTLE_DELAY_MS = 500;                // Settling time after switch hit

// Encoder ISR
void IRAM_ATTR pulseInterrupt() {
  if (encoderEnabled) pulseCount++;
}

void setup() {
  Serial.begin(115200);
  while (!Serial);  // Wait for serial connection

  // Configure pins
  pinMode(DIR_PIN, OUTPUT);
  pinMode(HOME_SWITCH_PIN, INPUT_PULLUP);    // Internal pullup for switch
  pinMode(RIGHT_SWITCH_PIN, INPUT_PULLUP);   // Internal pullup for switch
  pinMode(ENCODER_PIN, INPUT_PULLUP);        // Internal pullup for encoder
  
  // Attach encoder interrupt
  attachInterrupt(digitalPinToInterrupt(ENCODER_PIN), pulseInterrupt, RISING);

  // Initialize stepper at current position as zero
  stepper.setCurrentPosition(0);
  printMenu();
}

void loop() {
  // Handle user input from serial console
  if (Serial.available() > 0) handleSerialInput();
  
  // Update switch states with debouncing
  readHomeSwitch();

  // Execute current mode's control logic
  switch (currentMode) {
    case ACCEL: accelModeLoop(); break;
    case CONST_VEL: constVelModeLoop(); break;
    case CALIB: calibModeLoop(); break;
    case TRAPEZOID: trapezoidModeLoop(); break;
    case DISTANCE: distanceModeLoop(); break;
    default: break;  // NONE mode - idle
  }

  // Execute one step if motor is moving (non-blocking)
  stepper.run();
}

// === Menu & Serial Input Handling ===

void printMenu() {
  Serial.println("\n=== Select Stepper Motor Mode ===");
  Serial.println("1: Acceleration mode (velocity & acceleration)");
  Serial.println("2: Constant velocity mode");
  Serial.println("3: Calibration/Homing mode");
  Serial.println("4: Trapezoidal motion mode");
  Serial.println("5: Distance measurement mode");
  Serial.println("Type 1, 2, 3, 4, or 5 and press Enter.");
  Serial.println("Type 'stop' anytime for EMERGENCY STOP.");
  Serial.println("Type 'return' when at end position to return to start.");
}

void handleSerialInput() {
  String input = Serial.readStringUntil('\n');
  input.trim();  // Remove whitespace

  // Emergency stop command - works from any mode
  if (input.equalsIgnoreCase("stop")) {
    stepper.stop();                    // Stop motor immediately
    currentMode = NONE;                // Reset to idle mode
    // Reset all mode flags to safe state
    accel_motionInProgress = false;
    accel_waitingAtEnd = false;
    const_motionInProgress = false;
    const_returning = false;
    const_waitingAtEnd = false;
    trap_motionInProgress = false;
    trap_returning = false;
    trapState = TRAP_IDLE;
    homingState = WAITING_FOR_START;
    dist_motionInProgress = false;
    dist_waitingAtEnd = false;
    encoderEnabled = false;
    Serial.println("EMERGENCY STOP activated! Motor stopped.");
    printMenu();
    return;
  }

  // Return command - works when motor is waiting at end position
  if (input.equalsIgnoreCase("return")) {
    handleReturnCommand();
    return;
  }

  // Mode selection when in idle state
  if (currentMode == NONE) {
    if (input == "1") {
      currentMode = ACCEL;
      accelModeSetup();
    } else if (input == "2") {
      currentMode = CONST_VEL;
      constVelModeSetup();
    } else if (input == "3") {
      currentMode = CALIB;
      calibModeSetup();
    } else if (input == "4") {
      currentMode = TRAPEZOID;
      trapezoidModeSetup();
    } else if (input == "5") {
      currentMode = DISTANCE;
      distanceModeSetup();
    } else {
      Serial.println("Invalid selection. Type 1, 2, 3, 4, or 5.");
    }
    return;
  }

  // Route input to current mode's handler
  if (currentMode == ACCEL) accelModeSerial(input);
  else if (currentMode == CONST_VEL) constVelModeSerial(input);
  else if (currentMode == CALIB) calibModeSerial(input);
  else if (currentMode == TRAPEZOID) trapezoidModeSerial(input);
  else if (currentMode == DISTANCE) distanceModeSerial(input);
}

void handleReturnCommand() {
  bool returnExecuted = false;
  
  switch (currentMode) {
    case ACCEL:
      if (accel_waitingAtEnd) {
        // Configure stepper with same parameters for return
        stepper.setMaxSpeed(velocity_steps);
        stepper.setAcceleration(acceleration_steps);
        stepper.moveTo(0);  // Return to start position
        accel_returning = true;
        accel_waitingAtEnd = false;
        Serial.println("Returning to start with same acceleration parameters...");
        returnExecuted = true;
      }
      break;
      
    case CONST_VEL:
      if (const_waitingAtEnd) {
        // Configure return journey at same speed
        float returnSpeed = const_currentVelocity * STEPS_PER_METER;
        stepper.setMaxSpeed(returnSpeed);
        stepper.setAcceleration(returnSpeed * 2);
        stepper.moveTo(0);  // Return to start
        const_returning = true;
        const_waitingAtEnd = false;
        Serial.println("Returning to start at same constant velocity...");
        returnExecuted = true;
      }
      break;
      
    case TRAPEZOID:
      if (trapState == TRAP_WAITING_AT_END) {
        // Start return journey with same parameters
        trapState = TRAP_RETURNING;
        trap_returning = true;
        stepper.setMaxSpeed(trapParams.cruiseSpeed_steps);
        stepper.setAcceleration(trapParams.acceleration_steps);
        stepper.moveTo(0);  // Return to start position
        Serial.println("Returning to start with same trapezoidal parameters...");
        returnExecuted = true;
      }
      break;
      
    case DISTANCE:
      if (dist_waitingAtEnd) {
        // Configure return journey
        pulseCount = 0;  // Reset pulse counter
        float returnSpeed = dist_velocity * STEPS_PER_METER;
        stepper.setMaxSpeed(returnSpeed);
        stepper.setAcceleration(returnSpeed * 2);
        stepper.moveTo(0);  // Return to start
        dist_returning = true;
        dist_waitingAtEnd = false;
        Serial.println("Returning to start at same velocity...");
        returnExecuted = true;
      }
      break;
      
    default:
      break;
  }
  
  if (!returnExecuted) {
    Serial.println("Return command not applicable. Motor must be at end position and waiting.");
  }
}

// === Acceleration Mode Implementation ===

void accelModeSetup() {
  // Reset mode state
  accel_returning = false;
  accel_motionInProgress = false;
  accel_waitingForVelocity = true;
  accel_waitingAtEnd = false;
  
  Serial.println("\n--- Acceleration Mode ---");
  Serial.println("Enter velocity in m/s (e.g. 0.05):");
}

void accelModeSerial(String input) {
  if (accel_waitingForVelocity) {
    // First input: velocity in m/s, convert to steps/sec
    velocity_steps = input.toFloat() * STEPS_PER_METER;
    Serial.println("Enter acceleration in m/s² (e.g. 0.02):");
    accel_waitingForVelocity = false;
  } else {
    // Second input: acceleration in m/s², convert to steps/sec²
    acceleration_steps = input.toFloat() * STEPS_PER_METER;
    
    // Configure stepper with user parameters
    stepper.setMaxSpeed(velocity_steps);
    stepper.setAcceleration(acceleration_steps);
    stepper.moveTo(-TARGET_POSITION);  // Move to end (negative direction)
    accel_motionInProgress = true;
    Serial.println("Moving to end position. Type 'return' when ready to return.");
  }
}

void accelModeLoop() {
  // Safety check: stop if limit switches are hit
  if ((stepper.currentPosition() > 0 && switchPressed) ||
      (stepper.currentPosition() < 0 && rightSwitchPressed)) {
    Serial.println("Limit switch hit! Stopping motor.");
    stepper.stop();
    stepper.setCurrentPosition(0);  // Reset position reference
    accel_motionInProgress = false;
    accel_waitingAtEnd = false;
    currentMode = NONE;
    printMenu();
    return;
  }

  if (!accel_motionInProgress) return;

  // Check if motor reached target position
  if (stepper.distanceToGo() == 0) {
    if (!accel_returning) {
      // Reached end, wait for return command
      accel_waitingAtEnd = true;
      Serial.println("Reached end position. Type 'return' to return to start.");
    } else {
      // Returned to start, motion complete
      accel_motionInProgress = false;
      accel_returning = false;
      accel_waitingAtEnd = false;
      currentMode = NONE;
      Serial.println("Acceleration mode complete!");
      printMenu();
    }
  }
}

// === Constant Velocity Mode Implementation ===

void constVelModeSetup() {
  Serial.println("\n--- Constant Velocity Mode ---");
  Serial.println("Enter velocity in m/s (e.g., 0.05):");
}

void constVelModeSerial(String input) {
  float velocity = input.toFloat();
  if (velocity > 0) {
    startConstVelMotion(velocity);
  } else {
    Serial.println("Invalid input. Enter a positive number.");
  }
}

void startConstVelMotion(float velocity) {
  // Validate velocity range
  if (velocity < 0.001 || velocity > 15.0) {
    Serial.println("Velocity out of range! (0.001 to 15.0)");
    return;
  }
  if (const_motionInProgress) {
    Serial.println("Motion already in progress.");
    return;
  }

  // Initialize motion state
  const_returning = false;
  const_motionInProgress = true;
  const_waitingAtEnd = false;
  const_currentVelocity = velocity;

  // Configure stepper for constant velocity (high acceleration for quick ramp-up)
  float velocity_steps = velocity * STEPS_PER_METER;
  stepper.setMaxSpeed(velocity_steps);
  stepper.setAcceleration(velocity_steps * 2);  // 2x velocity for quick start
  stepper.moveTo(-TARGET_POSITION);  // Move to end position
  Serial.println("Moving to end position. Type 'return' when ready to return.");
}

void constVelModeLoop() {
  // Safety check: stop if limit switches are hit
  if ((stepper.currentPosition() > 0 && switchPressed) ||
      (stepper.currentPosition() < 0 && rightSwitchPressed)) {
    Serial.println("Limit switch hit! Stopping motor.");
    stepper.stop();
    stepper.setCurrentPosition(0);
    const_motionInProgress = false;
    const_waitingAtEnd = false;
    currentMode = NONE;
    printMenu();
    return;
  }

  if (!const_motionInProgress) return;

  // Check if reached end position
  if (stepper.distanceToGo() == 0) {
    if (!const_returning && !const_waitingAtEnd) {
      // Reached end, wait for return command
      const_waitingAtEnd = true;
      Serial.println("Reached end position. Type 'return' to return to start.");
    }
  }

  // Check if return journey is complete
  if (const_returning && stepper.distanceToGo() == 0) {
    const_motionInProgress = false;
    const_returning = false;
    const_waitingAtEnd = false;
    currentMode = NONE;
    Serial.println("Constant velocity mode complete!");
    printMenu();
  }
}

// === Trapezoidal Mode Implementation ===

void trapezoidModeSetup() {
  // Reset parameter collection
  trapInputStep = 0;
  trap_motionInProgress = false;
  trap_returning = false;
  trapState = TRAP_IDLE;
  
  Serial.println("\n--- Trapezoidal Motion Mode ---");
  Serial.println("This mode creates a trapezoidal velocity profile over 80cm travel.");
  Serial.println("Enter acceleration distance in meters (e.g., 0.1 for 10cm):");
  Serial.println("Note: Accel + Decel distances should be < 0.8m total travel");
}

void trapezoidModeSerial(String input) {
  // Check if user wants to start motion after parameters are set
  if (trapInputStep > 3 && input.equalsIgnoreCase("start")) {
    startTrapezoidalMotion();
    return;
  }
  
  // Collect motion parameters sequentially
  if (trapInputStep <= 3) {
    float value = input.toFloat();
    
    switch (trapInputStep) {
      case 0: // Acceleration distance
        if (value <= 0 || value >= MAX_TRAVEL_M) {
          Serial.println("Invalid acceleration distance. Must be > 0 and < 0.8m");
          return;
        }
        trapParams.accelDistance_m = value;
        trapInputStep = 1;
        Serial.println("Enter deceleration distance in meters (e.g., 0.15 for 15cm):");
        break;
        
      case 1: // Deceleration distance
        if (value <= 0 || value >= MAX_TRAVEL_M) {
          Serial.println("Invalid deceleration distance. Must be > 0 and < 0.8m");
          return;
        }
        // Validate total distance doesn't exceed travel range
        if ((trapParams.accelDistance_m + value) >= MAX_TRAVEL_M) {
          Serial.println("Error: Accel + Decel distances exceed total travel distance!");
          Serial.print("Current total: ");
          Serial.print(trapParams.accelDistance_m + value);
          Serial.println("m (must be < 0.8m)");
          return;
        }
        trapParams.decelDistance_m = value;
        trapInputStep = 2;
        Serial.println("Enter acceleration/deceleration rate in m/s² (e.g., 0.05):");
        break;
        
      case 2: // Acceleration rate
        if (value <= 0) {
          Serial.println("Invalid acceleration. Must be > 0");
          return;
        }
        trapParams.acceleration_ms2 = value;
        trapInputStep = 3;
        Serial.println("Enter cruise speed in m/s (e.g., 0.1):");
        break;
        
      case 3: // Cruise speed
        if (value <= 0) {
          Serial.println("Invalid cruise speed. Must be > 0");
          return;
        }
        trapParams.cruiseSpeed_ms = value;
        trapInputStep = 4; // Mark parameter collection complete
        
        // Calculate and validate parameters
        if (calculateTrapezoidalParams()) {
          printTrapezoidalSummary();
          Serial.println("Type 'start' to begin trapezoidal motion:");
        } else {
          Serial.println("Invalid parameters! Resetting...");
          trapezoidModeSetup();
        }
        break;
    }
  } else {
    // Parameters collected, waiting for start command
    Serial.println("Type 'start' to begin motion or 'stop' for emergency stop.");
  }
}

bool calculateTrapezoidalParams() {
  // Convert all parameters from meters to steps
  trapParams.accelDistance_steps = trapParams.accelDistance_m * STEPS_PER_METER;
  trapParams.decelStartPosition_steps = -(MAX_TRAVEL_M - trapParams.decelDistance_m) * STEPS_PER_METER;
  trapParams.acceleration_steps = trapParams.acceleration_ms2 * STEPS_PER_METER;
  trapParams.cruiseSpeed_steps = trapParams.cruiseSpeed_ms * STEPS_PER_METER;
  
  // Physics validation: check if cruise speed is achievable with given acceleration distance
  // Using kinematic equation: v² = u² + 2as (where u=0, initial velocity)
  float maxSpeedReachable = sqrt(2.0 * trapParams.acceleration_ms2 * trapParams.accelDistance_m);
  
  if (trapParams.cruiseSpeed_ms > maxSpeedReachable) {
    Serial.println("Error: Cruise speed too high for given acceleration distance!");
    Serial.print("Maximum reachable speed with ");
    Serial.print(trapParams.accelDistance_m);
    Serial.print("m accel distance: ");
    Serial.print(maxSpeedReachable);
    Serial.println(" m/s");
    return false;
  }
  
  return true;
}

void printTrapezoidalSummary() {
  Serial.println("\n--- Trapezoidal Motion Parameters ---");
  Serial.print("Acceleration distance: ");
  Serial.print(trapParams.accelDistance_m * 100);
  Serial.println(" cm");
  Serial.print("Deceleration distance: ");
  Serial.print(trapParams.decelDistance_m * 100);
  Serial.println(" cm");
  Serial.print("Cruise distance: ");
  Serial.print((MAX_TRAVEL_M - trapParams.accelDistance_m - trapParams.decelDistance_m) * 100);
  Serial.println(" cm");
  Serial.print("Acceleration rate: ");
  Serial.print(trapParams.acceleration_ms2);
  Serial.println(" m/s²");
  Serial.print("Cruise speed: ");
  Serial.print(trapParams.cruiseSpeed_ms);
  Serial.println(" m/s");
  Serial.println("----------------------------------------");
}

void startTrapezoidalMotion() {
  if (trap_motionInProgress) {
    Serial.println("Motion already in progress.");
    return;
  }
  
  // Initialize trapezoidal motion state
  trap_motionInProgress = true;
  trap_returning = false;
  trapState = TRAP_ACCELERATING;
  
  // Start acceleration phase: move to end of acceleration distance
  stepper.setMaxSpeed(trapParams.cruiseSpeed_steps);
  stepper.setAcceleration(trapParams.acceleration_steps);
  stepper.moveTo(-trapParams.accelDistance_steps);
  
  Serial.println("Starting trapezoidal motion...");
  Serial.println("Phase: ACCELERATING");
}

void trapezoidModeLoop() {
  // Safety checks for limit switches
  if ((stepper.currentPosition() > 0 && switchPressed) ||
      (stepper.currentPosition() < 0 && rightSwitchPressed)) {
    Serial.println("Limit switch hit! Stopping motor.");
    stepper.stop();
    stepper.setCurrentPosition(0);
    trap_motionInProgress = false;
    trapState = TRAP_IDLE;
    currentMode = NONE;
    printMenu();
    return;
  }
  
  if (!trap_motionInProgress) return;
  
  // State machine for trapezoidal motion phases
  switch (trapState) {
    case TRAP_ACCELERATING:
      if (stepper.distanceToGo() == 0) {
        // Acceleration complete, transition to cruise phase
        trapState = TRAP_CRUISING;
        stepper.setMaxSpeed(trapParams.cruiseSpeed_steps);
        stepper.setAcceleration(trapParams.cruiseSpeed_steps * 10); // High accel to maintain constant speed
        stepper.moveTo(trapParams.decelStartPosition_steps);  // Move to deceleration start point
        Serial.println("Phase: CRUISING");
      }
      break;
      
    case TRAP_CRUISING:
      if (stepper.distanceToGo() == 0) {
        // Cruise complete, transition to deceleration phase
        trapState = TRAP_DECELERATING;
        stepper.setMaxSpeed(trapParams.cruiseSpeed_steps);
        stepper.setAcceleration(trapParams.acceleration_steps);  // Use same decel rate as accel
        stepper.moveTo(-TARGET_POSITION);  // Move to final end position
        Serial.println("Phase: DECELERATING");
      }
      break;
      
    case TRAP_DECELERATING:
      if (stepper.distanceToGo() == 0) {
        // Deceleration complete, wait for return command
        trapState = TRAP_WAITING_AT_END;
        Serial.println("Reached end position. Type 'return' to return to start.");
      }
      break;
      
    case TRAP_WAITING_AT_END:
      // Waiting for return command - handled in handleReturnCommand()
      break;
      
    case TRAP_RETURNING:
      if (stepper.distanceToGo() == 0) {
        // Return journey complete, motion finished
        trap_motionInProgress = false;
        trap_returning = false;
        trapState = TRAP_IDLE;
        currentMode = NONE;
        Serial.println("Trapezoidal motion complete!");
        printMenu();
      }
      break;
      
    default:
      break;
  }
}

// === Calibration/Homing Mode Implementation ===

void calibModeSetup() {
  homingState = WAITING_FOR_START;
  Serial.println("\n--- Calibration/Homing Mode ---");
  Serial.println("Type 'home' to start homing sequence.");
}

void calibModeSerial(String input) {
  if (input.equalsIgnoreCase("home")) {
    startHomingSequence();
  }
}

void startHomingSequence() {
  if (homingState == HOMING_IN_PROGRESS || homingState == MOVING_TO_START) {
    Serial.println("Homing already in progress.");
    return;
  }
  
  // Configure slow speed for safe homing
  float homingSpeedSteps = HOMING_SPEED_MS * STEPS_PER_METER;
  stepper.setMaxSpeed(homingSpeedSteps);
  stepper.setAcceleration(homingSpeedSteps * 2);  // Quick acceleration to homing speed
  stepper.moveTo(100000); // Move toward left switch (large positive value)
  
  // Initialize homing state
  homingState = HOMING_IN_PROGRESS;
  homingStartTime = millis();
  switchPressed = false;  // Clear any previous switch state
}

void calibModeLoop() {
  switch (homingState) {
    case WAITING_FOR_START: 
      break;  // Idle, waiting for 'home' command

    case HOMING_IN_PROGRESS:
      if (switchPressed) {
        // Home switch found, stop and set as position zero
        stepper.stop();
        delay(100);  // Brief settling delay
        stepper.setCurrentPosition(0);  // Set current position as home (zero)
        delay(SETTLE_DELAY_MS);  // Additional settling time

        // Move to start position (offset from home)
        float positioningSpeedSteps = POSITIONING_SPEED_MS * STEPS_PER_METER;
        stepper.setMaxSpeed(positioningSpeedSteps);
        stepper.setAcceleration(positioningSpeedSteps * 2);
        stepper.moveTo(-START_POSITION_STEPS);  // Move to start offset position
        homingState = MOVING_TO_START;
        
      } else if (millis() - homingStartTime > HOMING_TIMEOUT_MS) {
        // Timeout exceeded, homing failed
        stepper.stop();
        homingState = HOMING_FAILED;
        Serial.println("Homing timeout! Check switch.");
        
      } else if (stepper.distanceToGo() == 0 && !switchPressed) {
        // Reached end of travel without finding switch
        homingState = HOMING_FAILED;
        Serial.println("Switch not found within range.");
      }
      break;

    case MOVING_TO_START:
      if (stepper.distanceToGo() == 0) {
        // Reached start position, homing complete
        homingState = HOMING_COMPLETE;
        currentMode = NONE;
        Serial.println("Homing complete. At 25mm from home.");
        printMenu();
      }
      break;

    case HOMING_COMPLETE: 
      break;  // Homing finished successfully
      
    case HOMING_FAILED: 
      break;  // Homing failed, user must restart
  }
}

// === Distance Mode Implementation ===

void distanceModeSetup() {
  // Reset mode state
  dist_motionInProgress = false;
  dist_returning = false;
  dist_waitingAtEnd = false;
  dist_velocity = 0.0;
  lastPrintTime = 0;
  
  Serial.println("\n--- Distance Measurement Mode ---");
  Serial.println("Enter velocity in m/s (e.g., 0.05):");
  Serial.println("Motor will move at constant speed while counting encoder pulses.");
}

void distanceModeSerial(String input) {
  float velocity = input.toFloat();
  if (velocity <= 0) {
    Serial.println("Invalid velocity. Enter a positive number.");
    return;
  }
  
  // Validate velocity range
  if (velocity < 0.001 || velocity > 15.0) {
    Serial.println("Velocity out of range! (0.001 to 15.0 m/s)");
    return;
  }
  
  // Initialize motion state
  dist_velocity = velocity;
  pulseCount = 0;  // Reset encoder counter
  encoderEnabled = true;  // Enable pulse counting
  
  // Configure stepper for constant velocity
  float velocity_steps = velocity * STEPS_PER_METER;
  stepper.setMaxSpeed(velocity_steps);
  stepper.setAcceleration(velocity_steps * 2);  // Quick acceleration
  stepper.moveTo(-TARGET_POSITION);  // Move to end position
  
  dist_motionInProgress = true;
  lastPrintTime = millis();  // Initialize print timer
  Serial.println("Starting motion. Counting encoder pulses...");
}

void distanceModeLoop() {
  // Safety check: stop if limit switches are hit
  if ((stepper.currentPosition() > 0 && switchPressed) ||
      (stepper.currentPosition() < 0 && rightSwitchPressed)) {
    Serial.println("Limit switch hit! Stopping motor.");
    stepper.stop();
    stepper.setCurrentPosition(0);
    dist_motionInProgress = false;
    dist_waitingAtEnd = false;
    encoderEnabled = false;
    currentMode = NONE;
    printMenu();
    return;
  }

  if (!dist_motionInProgress) return;

  // Print encoder data at regular intervals
  unsigned long currentTime = millis();
  if (currentTime - lastPrintTime >= PRINT_INTERVAL) {
    float distance = pulseCount / PULSES_PER_METER;
    
    if (!dist_returning) {
      Serial.print("Outbound - Pulses: ");
      Serial.print(pulseCount);
      Serial.print(", Distance from start: ");
      Serial.print(distance, 3);
      Serial.println(" m");
    } else {
      Serial.print("Return - Pulses: ");
      Serial.print(pulseCount);
      Serial.print(", Distance from end: ");
      Serial.print(distance, 3);
      Serial.println(" m");
    }
    lastPrintTime = currentTime;
  }

  // Check if reached end position
  if (stepper.distanceToGo() == 0) {
    if (!dist_returning && !dist_waitingAtEnd) {
      // Reached end, wait for return command
      dist_waitingAtEnd = true;
      encoderEnabled = false;  // Stop counting during wait
      Serial.println("Reached end position. Type 'return' to return to start.");
    }
  }

  // Check if return journey is complete
  if (dist_returning && stepper.distanceToGo() == 0) {
    dist_motionInProgress = false;
    dist_returning = false;
    dist_waitingAtEnd = false;
    encoderEnabled = false;
    currentMode = NONE;
    Serial.println("Distance measurement complete!");
    printMenu();
  }
}

// === Switch Reading with Debounce ===

void readHomeSwitch() {
  // Read and debounce left home switch (active low with pullup)
  bool currentLeftSwitch = digitalRead(HOME_SWITCH_PIN) == LOW;
  if (currentLeftSwitch != switchPressed && millis() - lastSwitchTime > DEBOUNCE_DELAY_MS) {
    switchPressed = currentLeftSwitch;  // Update debounced state
    lastSwitchTime = millis();
  }

  // Read and debounce right safety switch (active low with pullup)
  bool currentRightSwitch = digitalRead(RIGHT_SWITCH_PIN) == LOW;
  if (currentRightSwitch != rightSwitchPressed && millis() - lastRightSwitchTime > DEBOUNCE_DELAY_MS) {
    rightSwitchPressed = currentRightSwitch;  // Update debounced state
    lastRightSwitchTime = millis();
  }
}